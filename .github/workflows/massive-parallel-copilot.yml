name: Massive Parallel Execution with Copilot

on:
  issues:
    types: [opened, labeled]
  workflow_dispatch:
    inputs:
      parent_issue:
        description: 'Parent issue to split into parallel tasks'
        required: true
      parallelism_level:
        description: 'Number of parallel workers (1-100)'
        required: false
        default: '50'

permissions:
  issues: write
  contents: write
  pull-requests: write
  actions: write

jobs:
  split-and-parallelize:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'parallel-execution')) ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Analyze and Split Work with Copilot
        id: split
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        with:
          script: |
            const issue = context.payload.issue || { 
              number: parseInt('${{ github.event.inputs.parent_issue }}') 
            };
            
            const parallelismLevel = parseInt('${{ github.event.inputs.parallelism_level }}' || '50');
            
            // Get issue details
            let issueData;
            if (context.eventName === 'workflow_dispatch') {
              const { data } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number
              });
              issueData = data;
            } else {
              issueData = issue;
            }
            
            // Parse workflow or task description
            const issueBody = issueData.body || '';
            const taskMatch = issueBody.match(/```json\n([\s\S]*?)\n```/);
            
            let workItems = [];
            
            if (taskMatch) {
              // Parse structured workflow
              const workflow = JSON.parse(taskMatch[1]);
              const nodes = workflow.nodes || [];
              
              // Split each node into micro-tasks
              for (const node of nodes) {
                const microTasks = await splitNodeIntoMicroTasks(node, parallelismLevel);
                workItems.push(...microTasks);
              }
            } else {
              // Use AI to analyze unstructured task and split it
              workItems = await analyzeAndSplitWithAI(issueBody, parallelismLevel);
            }
            
            // Limit to parallelism level
            workItems = workItems.slice(0, parallelismLevel);
            
            console.log(`Split work into ${workItems.length} parallel tasks`);
            
            // Function to split node into micro-tasks
            async function splitNodeIntoMicroTasks(node, maxTasks) {
              const tasks = [];
              const nodeType = node.type;
              const config = node.config || {};
              
              // Different splitting strategies based on node type
              switch (nodeType) {
                case 'agent':
                  if (config.subTasks) {
                    // Each subtask becomes a parallel work item
                    config.subTasks.forEach((subTask, idx) => {
                      tasks.push({
                        id: \`${node.id}_subtask_${idx}\`,
                        type: 'copilot-task',
                        title: subTask.task || subTask.name || \`Sub-task ${idx + 1}\`,
                        description: JSON.stringify(subTask),
                        agentType: subTask.agent || 'worker',
                        parentNode: node.id,
                        priority: subTask.priority || 'medium'
                      });
                    });
                  } else {
                    // Create parallel micro-tasks for complex work
                    const microTaskCount = Math.min(10, Math.floor(maxTasks / nodes.length));
                    for (let i = 0; i < microTaskCount; i++) {
                      tasks.push({
                        id: \`${node.id}_micro_${i}\`,
                        type: 'copilot-task',
                        title: \`${node.id}: Micro-task ${i + 1}\`,
                        description: \`Execute portion ${i + 1} of ${microTaskCount}\`,
                        agentType: config.agentType || 'worker',
                        parentNode: node.id,
                        priority: 'medium'
                      });
                    }
                  }
                  break;
                
                case 'ai-task':
                  // Split AI task into analysis chunks
                  const prompt = config.prompt || '';
                  const chunks = splitPromptIntoChunks(prompt, 5);
                  chunks.forEach((chunk, idx) => {
                    tasks.push({
                      id: \`${node.id}_chunk_${idx}\`,
                      type: 'copilot-ai-task',
                      title: \`${node.id}: AI Analysis ${idx + 1}\`,
                      description: chunk,
                      model: config.model || 'gpt-4',
                      parentNode: node.id,
                      priority: 'high'
                    });
                  });
                  break;
                
                case 'parallel':
                  // Already parallel, create worker for each
                  const parallelTasks = config.tasks || [];
                  parallelTasks.forEach((task, idx) => {
                    tasks.push({
                      id: \`${node.id}_parallel_${idx}\`,
                      type: 'copilot-task',
                      title: \`Parallel task ${idx + 1}\`,
                      description: JSON.stringify(task),
                      agentType: task.agentType || 'worker',
                      parentNode: node.id,
                      priority: 'high'
                    });
                  });
                  break;
                
                case 'code-generation':
                  // Split by components/files
                  const components = ['models', 'controllers', 'views', 'tests', 'docs'];
                  components.forEach((component, idx) => {
                    tasks.push({
                      id: \`${node.id}_${component}\`,
                      type: 'copilot-code-gen',
                      title: \`Generate ${component}\`,
                      description: \`Generate ${component} component\`,
                      language: config.language || 'javascript',
                      parentNode: node.id,
                      priority: 'high'
                    });
                  });
                  break;
                
                default:
                  // Generic split
                  tasks.push({
                    id: node.id,
                    type: 'copilot-task',
                    title: node.id,
                    description: JSON.stringify(config),
                    agentType: 'worker',
                    parentNode: node.id,
                    priority: 'medium'
                  });
              }
              
              return tasks;
            }
            
            // Function to analyze unstructured task with AI
            async function analyzeAndSplitWithAI(taskDescription, maxTasks) {
              // This would use Copilot/GPT to intelligently split the task
              // For now, create structured parallel tasks
              const tasks = [];
              
              // Common development phases that can run in parallel
              const phases = [
                'Requirements Analysis',
                'Architecture Design',
                'Database Schema',
                'API Design',
                'Frontend Components',
                'Backend Services',
                'Authentication',
                'Testing Framework',
                'Documentation',
                'Deployment Config'
              ];
              
              phases.slice(0, Math.min(phases.length, maxTasks)).forEach((phase, idx) => {
                tasks.push({
                  id: \`task_${idx}\`,
                  type: 'copilot-task',
                  title: phase,
                  description: \`${phase} for: ${taskDescription.substring(0, 100)}\`,
                  agentType: 'worker',
                  parentNode: 'root',
                  priority: 'medium'
                });
              });
              
              return tasks;
            }
            
            // Helper to split prompt into chunks
            function splitPromptIntoChunks(prompt, numChunks) {
              const words = prompt.split(' ');
              const chunkSize = Math.ceil(words.length / numChunks);
              const chunks = [];
              
              for (let i = 0; i < numChunks; i++) {
                const start = i * chunkSize;
                const end = start + chunkSize;
                chunks.push(words.slice(start, end).join(' '));
              }
              
              return chunks;
            }
            
            core.setOutput('work_items', JSON.stringify(workItems));
            core.setOutput('total_items', workItems.length);
            
            return workItems;
      
      - name: Create Parallel Worker Issues
        id: create_issues
        uses: actions/github-script@v7
        with:
          script: |
            const workItems = JSON.parse('${{ steps.split.outputs.work_items }}');
            const parentIssue = context.payload.issue?.number || parseInt('${{ github.event.inputs.parent_issue }}');
            
            const createdIssues = [];
            
            // Create an issue for each work item
            for (const item of workItems) {
              const { data: workerIssue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: \`[Copilot Worker] ${item.title}\`,
                body: \`**ğŸ¤– Parallel Execution Worker**

**Parent Issue**: #${parentIssue}
**Worker ID**: ${item.id}
**Type**: ${item.type}
**Priority**: ${item.priority}

### Task Details

${item.description}

### Copilot Instructions

This is a parallel execution task. GitHub Copilot should:
1. Analyze the task requirements
2. Generate necessary code/content
3. Create a pull request with changes
4. Report results back to parent issue

### Configuration

\`\`\`json
${JSON.stringify(item, null, 2)}
\`\`\`

---

*Auto-created by Massive Parallel Execution System*
*This worker will execute independently in parallel with ${workItems.length - 1} other workers*\`,
                labels: [
                  'copilot-worker',
                  'parallel-execution',
                  \`parent:${parentIssue}\`,
                  \`priority:${item.priority}\`,
                  \`type:${item.type}\`
                ],
                assignees: [] // Copilot will work on these
              });
              
              createdIssues.push({
                issueNumber: workerIssue.number,
                issueUrl: workerIssue.html_url,
                workerId: item.id,
                title: item.title
              });
              
              console.log(\`Created worker issue #${workerIssue.number} for ${item.title}\`);
            }
            
            core.setOutput('created_issues', JSON.stringify(createdIssues));
            
            return createdIssues;
      
      - name: Trigger Parallel Execution
        uses: actions/github-script@v7
        with:
          script: |
            const createdIssues = JSON.parse('${{ steps.create_issues.outputs.created_issues }}');
            const parentIssue = context.payload.issue?.number || parseInt('${{ github.event.inputs.parent_issue }}');
            
            // Trigger copilot-worker workflow for each issue
            for (const issue of createdIssues) {
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'copilot-worker.yml',
                  ref: 'main',
                  inputs: {
                    worker_issue: issue.issueNumber.toString(),
                    parent_issue: parentIssue.toString()
                  }
                });
                
                console.log(\`Triggered worker for issue #${issue.issueNumber}\`);
              } catch (error) {
                console.log(\`Could not trigger workflow for #${issue.issueNumber}: ${error.message}\`);
              }
            }
      
      - name: Update Parent Issue
        uses: actions/github-script@v7
        with:
          script: |
            const createdIssues = JSON.parse('${{ steps.create_issues.outputs.created_issues }}');
            const parentIssue = context.payload.issue?.number || parseInt('${{ github.event.inputs.parent_issue }}');
            
            const updateComment = \`## âš¡ Massive Parallel Execution Started

**ğŸš€ Split into ${createdIssues.length} Parallel Workers**

Each worker will execute independently using GitHub Copilot and Codex, enabling ${createdIssues.length}x speedup!

### Worker Issues

${createdIssues.map((issue, idx) => \`${idx + 1}. [#${issue.issueNumber}](${issue.issueUrl}) - ${issue.title}\`).join('\n')}

### Execution Model

\`\`\`
Parent Issue #${parentIssue}
â”‚
â”œâ”€ Worker #${createdIssues[0]?.issueNumber} â”€â”
â”œâ”€ Worker #${createdIssues[1]?.issueNumber} â”€â”¤
â”œâ”€ Worker #${createdIssues[2]?.issueNumber} â”€â”¤
â”œâ”€ ...                  â”œâ”€ All executing
â”œâ”€ Worker #${createdIssues[createdIssues.length - 2]?.issueNumber} â”€â”¤   in parallel!
â””â”€ Worker #${createdIssues[createdIssues.length - 1]?.issueNumber} â”€â”˜
\`\`\`

### What's Happening

- âœ… Work split into ${createdIssues.length} independent tasks
- âœ… Each task assigned to a dedicated worker issue
- âœ… GitHub Copilot analyzing each task simultaneously
- âœ… Codex generating code for all workers in parallel
- âœ… Results will be aggregated automatically

**Estimated speedup**: ${createdIssues.length}x faster than sequential execution!

Track progress by watching the worker issues above. Each will report back when complete.\`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parentIssue,
              body: updateComment
            });
            
            // Add labels
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parentIssue,
              labels: ['parallel-executing', 'copilot-powered', \`workers:${createdIssues.length}\`]
            });
